{
  "name": "emily",
  "description": "runtime agnostic JS library for scalable web applications",
  "version": "1.3.5",
  "homepage": "http://flams.github.com/emily/",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/flams/emily/master/LICENSE"
    }
  ],
  "files": [
    "build",
    "LICENSE",
    "emily-server.js"
  ],
  "author": {
    "name": "Olivier Scherrer",
    "email": "pode.fr@gmail.com"
  },
  "dependencies": {
    "requirejs": ">=2.0.4"
  },
  "keywords": [
    "library",
    "AMD/commonJS",
    "Promise",
    "Observable",
    "StateMachine",
    "Store",
    "scalable webapp"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:flams/emily.git"
  },
  "bugs": {
    "url": "https://github.com/flams/emily/issues"
  },
  "main": "emily-server.js",
  "engines": {
    "node": ">= 0.6.0"
  },
  "readme": "###What is Emily?\n\n * Emily is a JS library for building scalable web applications.\n * It's runtime agnostic as it doesn't rely on the DOM.\n * It's ready for realtime applications.\n * It's only a set of AMD/commonJS modules, your module loader is the framework\n * It's ready for being used with other frameworks.\n * It only relies on standard features\n * It eases the development of MV* applications by providing the M\n\n###What modules does it provide?\n\n * Observable: the all mighty observer design pattern.\n * Store: the spine of your MV* application.\n * Promise: a fully compliant promise/A+ implementation following https://github.com/promises-aplus/promises-tests\n * StateMachine: don't hide your states and transitions behind if/else anymore.\n * Transport: make requests to anything node.js has access to.\n * Tools: these functions you always need and rewrite.\n\n###How do I use it?\n\n####In the browser:\n\nEmily requires an AMD/commonJS compatible loader. I use requirejs: http://requirejs.org/\nDownload the latest version of Emily here: http://flams.github.com/emily/\n\n```html\n\t<script src=\"require.js\"></script>\n\t<script src=\"Emily.js\"></script>\n```\n\n```js\n\trequire([\"Module\"], function (Module) {\n\t\t// Do what you want with Module\n\t});\n```\n\n####In node:\n\n```\nnpm install requirejs emily\n```\n\n```js\n\tvar requirejs = require(\"requirejs\");\n\t\temily = require(\"emily\");\n\n\trequirejs([\"Module\"], function (Module) {\n\t\t// Do what you want with Module\n\t});\n```\n\n### Integration tests: (Emily 1.3.4)\n\n##Observable\n\n```js\ndescribe(\"Observable implements the Observer design pattern, also called publish subscribe\", function () {\n\n\tit(\"has a watch function for adding a listener\", function () {\n\t\tvar observable = new Observable();\n\n\t\tvar handle = observable.watch(\"topic\", function listener() {\n\t\t\t// action to execute when something is published on the topic\n\t\t}, this);\n\t});\n\n\tit(\"has a notify function for publishing something on a topic\", function () {\n\t\tvar observable = new Observable(),\n\t\t\tmessage;\n\n\t\tobservable.watch(\"topic\", function listener(something) {\n\t\t\tmessage = something;\n\t\t});\n\n\t\tobservable.notify(\"topic\", \"hello\");\n\n\t\texpect(message).toBe(\"hello\");\n\t});\n\n\tit(\"notifies several listeners in the order they were added\", function () {\n\t\tvar observable = new Observable(),\n\t\t\torder = [];\n\n\t\tobservable.watch(\"topic\", function listener1() {  order.push(1); });\n\t\tobservable.watch(\"topic\", function listener2() {  order.push(2); });\n\t\tobservable.watch(\"topic\", function listener3() {  order.push(3); });\n\n\t\tobservable.notify(\"topic\");\n\n\t\texpect(order[0]).toBe(1);\n\t\texpect(order[1]).toBe(2);\n\t\texpect(order[2]).toBe(3);\n\t});\n\n\tit(\"should continue publishing on all the listeners even if one of them fails\", function () {\n\t\tvar observable = new Observable(),\n\t\t\torder = [];\n\n\t\tobservable.watch(\"topic\", function listener1() {  order.push(1); });\n\t\tobservable.watch(\"topic\", function listener2() {  throw new Error(\"this listener fails\"); });\n\t\tobservable.watch(\"topic\", function listener3() {  order.push(3); });\n\n\t\tobservable.notify(\"topic\");\n\n\t\texpect(order[0]).toBe(1);\n\t\texpect(order[1]).toBe(3);\n\t});\n\n\tit(\"can bind the this object of a listener to a given object and pass multiple things on the topic\", function () {\n\t\tvar observable = new Observable(),\n\t\t\tmessage1,\n\t\t\tmessage2,\n\t\t\tmessage3,\n\t\t\tcontext;\n\n\t\tobservable.watch(\"topic\", function listener(something1, something2, something3) {\n\t\t\tmessage1 = something1;\n\t\t\tmessage2 = something2;\n\t\t\tmessage3 = something3;\n\t\t\tcontext = this;\n\t\t}, this);\n\n\t\tobservable.notify(\"topic\", \"hello\", \"this is\", \"emily\");\n\n\t\texpect(message1).toBe(\"hello\");\n\t\texpect(message2).toBe(\"this is\");\n\t\texpect(message3).toBe(\"emily\");\n\t\texpect(context).toBe(this);\n\t});\n\n\tit(\"can remove a listener on a topic\", function () {\n\t\tvar observable = new Observable(),\n\t\t\tremoved = true;\n\n\t\tvar handle = observable.watch(\"topic\", function listener(something) {\n\t\t\tremoved = false;\n\t\t});\n\n\t\t// Remove the listener so it doesn't get called anymore\n\t\tobservable.unwatch(handle);\n\n\t\tobservable.notify(\"topic\");\n\n\t\texpect(removed).toBe(true);\n\t});\n\n\tit(\"can remove all listeners on a given topic\", function () {\n\t\tvar observable = new Observable(),\n\t\t\ttopics = [];\n\n\t\tobservable.watch(\"topic1\", function listener1() { topics.push(\"topic1\"); });\n\t\tobservable.watch(\"topic1\", function listener2() { topics.push(\"topic1\"); });\n\t\tobservable.watch(\"topic2\", function listener3() { topics.push(\"topic2\"); });\n\n\t\tobservable.unwatchAll(\"topic1\");\n\n\t\tobservable.notify(\"topic1\");\n\t\tobservable.notify(\"topic2\");\n\n\t\texpect(topics.length).toBe(1);\n\t\texpect(topics[0]).toBe(\"topic2\");\n\t});\n\n\tit(\"can remove all listeners\", function () {\n\t\tvar observable = new Observable(),\n\t\t\ttopics = [];\n\n\t\tobservable.watch(\"topic1\", function listener1() { topics.push(\"topic1\"); });\n\t\tobservable.watch(\"topic1\", function listener2() { topics.push(\"topic1\"); });\n\t\tobservable.watch(\"topic2\", function listener3() { topics.push(\"topic2\"); });\n\n\t\tobservable.unwatchAll();\n\n\t\tobservable.notify(\"topic1\");\n\t\tobservable.notify(\"topic2\");\n\n\t\texpect(topics.length).toBe(0);\n\t});\n\n});\n```\n\n##Tools\n\n```js\ndescribe(\"Tools.getGlobal can retrieve the global object\", function () {\n\n\tit(\"returns the global object\", function () {\n\t\texpect(Tools.getGlobal()).toBe(__Global);\n\t});\n});\n\ndescribe(\"Tools.mixin can add an object's properties to another object\", function () {\n\n\tit(\"takes the properties of the second object to mix them into the first one\", function () {\n\t\tvar source = {c: 30, d: 40},\n\t\t\tdestination = {a: 10, b: 20};\n\n\t\tTools.mixin(source, destination);\n\n\t\texpect(destination.a).toBe(10);\n\t\texpect(destination.b).toBe(20);\n\t\texpect(destination.c).toBe(30);\n\t\texpect(destination.d).toBe(40);\n\t});\n\n\tit(\"overrides the destination's values with the source ones by default\", function () {\n\t\tvar source = {c: 30, d: 40},\n\t\t\tdestination = {a: 10, b: 20, c: 25};\n\n\t\tTools.mixin(source, destination);\n\n\t\t// The destination's c has been replaced by the source's one\n\t\texpect(destination.c).toBe(30);\n\t});\n\n\tit(\"can prevent the desitnation's values to be replaced\", function () {\n\t\tvar source = {c: 30, d: 40},\n\t\t\tdestination = {a: 10, b: 20, c: 25};\n\n\t\tTools.mixin(source, destination, true);\n\n\t\t// The destination's c has been replaced by the source's one\n\t\texpect(destination.c).toBe(25);\n\t});\n\n\tit(\"also returns the destination object\", function () {\n\t\tvar source = {c: 30, d: 40},\n\t\t\tdestination = {a: 10, b: 20, c: 25};\n\n\t\texpect(Tools.mixin(source, destination, true)).toBe(destination);\n\t});\n});\n\ndescribe(\"Tools.count tells how many own properties an Object has\", function () {\n\n\tit(\"only counts own properties\", function () {\n\t\tvar object = {a: 10, b: 20};\n\n\t\texpect(Tools.count(object)).toBe(2);\n\t});\n\n});\n\ndescribe(\"Tools.compareObject tells if two objects have the same properties, useful for duck typing\", function () {\n\n\tit(\"tells if two objects have the same properties\", function () {\n\t\tvar o1 = {a: 1, c:3, b:4, x:10},\n\t\t\to2 = {a: 2, b:52, c:4, x:100},\n\t\t\to3 = {a: 5, b: 3, x: 50};\n\n\t\texpect(Tools.compareObjects(o1, o2)).toBe(true);\n\t\texpect(Tools.compareObjects(o2, o3)).toBe(false);\n\t});\n\n});\n\ndescribe(\"Tools.compareNumbers is useful for telling if a number if greater, equal or lower than another one\", function () {\n\n\tit(\"tells if a number is greater than another one\", function () {\n\t\texpect(Tools.compareNumbers(2.3, 2.2)).toBe(1);\n\t});\n\n\tit(\"tells if a number equals another one\", function () {\n\t\texpect(Tools.compareNumbers(2.2, 2.2)).toBe(0);\n\t});\n\n\tit(\"tells if a number is lower than another one\", function () {\n\t\texpect(Tools.compareNumbers(2.1, 2.2)).toBe(-1);\n\t});\n\n\tit(\"can ASC sort numbers when using Array.sort\", function () {\n\t\tvar array = [0, 2, 9, 4, 1, 7, 3, 12, 11, 5, 6, 8, 10];\n\n\t\tarray.sort(Tools.compareNumbers);\n\n\t\texpect(array[10]).toBe(10);\n\t\texpect(array[11]).toBe(11);\n\t});\n\n});\n\ndescribe(\"Tools.toArray transforms an array like object, like arguments or a nodeList to an actual array\", function () {\n\n\tit(\"transforms a list of arguments to an array\", function () {\n\t\t(function () {\n\t\t\tvar args = Tools.toArray(arguments);\n\n\t\t\texpect(Array.isArray(args)).toBe(true);\n\n\t\t})();\n\t});\n\n\tit(\"transforms a nodelist into an array\", function () {\n\t\tif (__Global.document) {\n\t\t\tvar all = document.querySelectorAll(\"*\");\n\n\t\t\texpect(Array.isArray(all)).toBe(true);\n\t\t}\n\t});\n});\n\ndescribe(\"Tools.loop abstracts the difference between iterating over an object and an array\", function () {\n\n\tit(\"can iterate over an array\", function () {\n\t\tvar array = [0, 1, 2, 3];\n\n\t\tvar _self = this;\n\n\t\tTools.loop(array, function (value, index, iterated) {\n\t\t\texpect(iterated).toBe(array);\n\t\t\texpect(array[index]).toBe(value);\n\t\t\t// The context in which to run this function can also be given\n\t\t\texpect(this).toBe(_self);\n\t\t}, this);\n\t});\n\n\tit(\"can iterate over an array which length varies\", function () {\n\t\tvar iterated = [1],\n\t\t\tnbOfCalls = 0;\n\n\t\tTools.loop(iterated, function (value) {\n\t\t\tif (nbOfCalls < 10) {\n\t\t\t\titerated.push(1);\n\t\t\t\tnbOfCalls++;\n\t\t\t}\n\t\t});\n\n\t\texpect(iterated.length).toBe(11);\n\t});\n\n\tit(\"can iterate over an object\", function () {\n\t\tvar object = {a: 10, b: 20};\n\n\t\tTools.loop(object, function (value, key, obj) {\n\t\t\texpect(object).toBe(obj);\n\t\t\texpect(object[key]).toBe(value);\n\t\t});\n\t});\n});\n\ndescribe(\"Tools.objectsDiffs returns an object describing the differences between two objects\", function () {\n\n\tit(\"tells what was added in an array\", function () {\n\t\tvar array1 = ['a', 'b', 'c'],\n\t\t\tarray2 = ['a', 'b', 'c', 'd', 'e'];\n\n\t\tvar diff = Tools.objectsDiffs(array1, array2);\n\t\t// The third item of array2 was added\n\t\texpect(diff.added[0]).toBe(3);\n\t\t// The fourth item too\n\t\texpect(diff.added[1]).toBe(4);\n\t});\n\n\tit(\"tells what was removed\", function () {\n\t\tvar array1 = ['a', 'b', 'c'],\n\t\t\tarray2 = ['a', 'b'];\n\n\t\tvar diff = Tools.objectsDiffs(array1, array2);\n\t\t// The third item of array2 was deleted\n\t\texpect(diff.deleted[0]).toBe(2);\n\t});\n\n\tit(\"tells what was updated\", function () {\n\t\tvar array1 = ['a', 'b', 'c'],\n\t\t\tarray2 = ['a', 'd', 'e'];\n\n\t\tvar diff = Tools.objectsDiffs(array1, array2);\n\t\t// The second item of array2 was updated\n\t\texpect(diff.updated[0]).toBe(1);\n\t\t// The third one too\n\t\texpect(diff.updated[1]).toBe(2);\n\t});\n\n\tit(\"tells what remains unchanged\", function () {\n\t\tvar array1 = ['a', 'b', 'c'],\n\t\t\tarray2 = ['a', 'd', 'e'];\n\n\t\tvar diff = Tools.objectsDiffs(array1, array2);\n\t\t// The first item remains unchanged\n\t\texpect(diff.unchanged[0]).toBe(0);\n\t});\n\n\tit(\"also works with objects\", function () {\n\t\tvar object1 = { a: 10, b: 20, c: 30},\n\t\t\tobject2 = { b: 30, c: 30, d: 40};\n\n\t\tvar diff = Tools.objectsDiffs(object1, object2);\n\n\t\texpect(diff.deleted[0]).toBe('a');\n\t\texpect(diff.updated[0]).toBe('b');\n\t\texpect(diff.unchanged[0]).toBe('c');\n\t\texpect(diff.added[0]).toBe('d');\n\t});\n\n});\n\ndescribe(\"Tools.jsonify returns the jsonified version of an object\", function () {\n\n\tit(\"returns a new object without the properties that can't be saved in a stringified json\", function () {\n\t\tvar nonJsonObject = {\n\t\t\ta: function () {},\n\t\t\tb: undefined,\n\t\t\tc:['emily']\n\t\t};\n\n\t\tvar jsonified = Tools.jsonify(nonJsonObject);\n\n\t\texpect(Tools.count(jsonified)).toBe(1);\n\t\texpect(jsonified.c[0]).toBe('emily');\n\t\texpect(jsonified.c).not.toBe(nonJsonObject.c);\n\t});\n\n});\n\ndescribe(\"Tools.setNestedProperty sets the property of an object nested in one or more objects\", function () {\n\n\tit(\"sets the property of an object deeply nested and creates the missing ones\", function () {\n\t\tvar object = {};\n\n\t\tTools.setNestedProperty(object, \"a.b.c.d.e.f\", \"emily\");\n\n\t\texpect(object.a.b.c.d.e.f).toBe(\"emily\");\n\t});\n\n\tit(\"returns the value if the first parameter is not an object\", function () {\n\t\texpect(Tools.setNestedProperty(\"emily\")).toBe(\"emily\");\n\t});\n\n\tit(\"also works if there are arrays in the path, but it doesn't create an array\", function () {\n\t\tvar object = {};\n\n\t\tTools.setNestedProperty(object, \"a.b.c.0.d\", \"emily\");\n\n\t\texpect(object.a.b.c[0].d).toBe(\"emily\");\n\t\texpect(Array.isArray(object.a.b.c)).toBe(false);\n\t});\n\n});\n\ndescribe(\"Tools.getNestedProperty gets the property of an object nested in other objects\", function () {\n\n\tit(\"gets the property of an object deeply nested in another one\", function () {\n\t\tvar object = {b:{c:{d:{e:1}}}};\n\n\t\texpect(Tools.getNestedProperty(object, \"b.c\")).toBe(object.b.c);\n\t\texpect(Tools.getNestedProperty(object, \"b.c.d.e\")).toBe(1);\n\t});\n\n\tit(\"also works if an array is in the path\", function () {\n\t\tvar object = {a: [{b: 1}]};\n\n\t\texpect(Tools.getNestedProperty(object, \"a.0.b\")).toBe(1);\n\t});\n\n});\n```\n\n## Store\n\n```js\ndescribe(\"Store is an observable data structure that publishes events whenever it's updated\", function () {\n\n\tit(\"can store its data in an object\", function () {\n\t\tvar store = new Store({});\n\n\t\tstore.set(\"key\", \"emily\");\n\t\tstore.set(\"otherKey\", 2);\n\n\t\texpect(store.get(\"key\")).toBe(\"emily\");\n\t\texpect(store.get(\"otherKey\")).toBe(2);\n\n\t\texpect(store.has(\"key\")).toBe(true);\n\n\t\texpect(store.del(\"key\")).toBe(true);\n\t\texpect(store.del(\"key\")).toBe(false);\n\t\texpect(store.has(\"key\")).toBe(false);\n\t});\n\n\tit(\"can store data in an array\", function () {\n\t\tvar store = new Store([]);\n\n\t\tstore.set(0, \"emily\");\n\t\tstore.set(1, 1);\n\n\t\texpect(store.get(0)).toBe(\"emily\");\n\t\texpect(store.get(1)).toBe(1);\n\n\t\texpect(store.del(0)).toBe(true);\n\t\texpect(store.get(0)).toBe(1);\n\t});\n\n\tit(\"can be initialized with data\", function () {\n\t\tvar store = new Store({a: 10});\n\n\t\texpect(store.get(\"a\")).toBe(10);\n\t});\n\n\tit(\"can be initialized two times with the same data but the data are not shared between them\", function () {\n\t\tvar data = {a: 10},\n\t\t\tstore1 = new Store(data),\n\t\t\tstore2 = new Store(data);\n\n\t\tstore1.set(\"b\", 20);\n\n\t\texpect(store2.has(\"b\")).toBe(false);\n\t});\n\n\tit(\"publishes events when a store is updated\", function () {\n\t\tvar store = new Store([]),\n\t\t\titemAdded = false,\n\t\t\titemUpdated = false,\n\t\t\titemDeleted = false,\n\t\t\thandle;\n\n\t\t// Listening to the events uses the same API as the Observable\n\t\thandle = store.watch(\"added\", function (key) {\n\t\t\titemAdded = key;\n\t\t}, this);\n\n\t\tstore.watch(\"updated\", function (key) {\n\t\t\titemUpdated = key;\n\t\t}, this);\n\n\t\tstore.watch(\"deleted\", function (key) {\n\t\t\titemDeleted = key;\n\t\t}, this);\n\n\t\tstore.set(0, \"emily\");\n\n\t\texpect(itemAdded).toBe(0);\n\n\t\tstore.set(0, \"olives\");\n\n\t\texpect(itemUpdated).toBe(0);\n\n\t\tstore.del(0);\n\n\t\texpect(itemDeleted).toBe(0);\n\n\t\tstore.unwatch(handle);\n\t});\n\n\tit(\"publishes events when a value in the store is updated\", function () {\n\t\tvar store = new Store([]),\n\t\t\tspyNewValue,\n\t\t\tspyOldValue,\n\t\t\tspyEvent,\n\t\t\thandle;\n\n\t\thandle = store.watchValue(0, function (newValue, action, oldValue) {\n\t\t\tspyNewValue = newValue;\n\t\t\tspyOldValue = oldValue;\n\t\t\tspyEvent = action;\n\t\t}, this);\n\n\t\tstore.set(0, \"emily\");\n\n\t\texpect(spyNewValue).toBe(\"emily\");\n\t\texpect(spyEvent).toBe(\"added\");\n\n\t\tstore.set(0, \"olives\");\n\n\t\texpect(spyNewValue).toBe(\"olives\");\n\t\texpect(spyEvent).toBe(\"updated\");\n\t\texpect(spyOldValue).toBe(\"emily\");\n\n\t\tstore.unwatchValue(handle);\n\t});\n\n\tit(\"works the same with objects\", function () {\n\t\tvar store = new Store({}),\n\t\t\tspyNewValue,\n\t\t\tspyOldValue,\n\t\t\tspyEvent;\n\n\t\tstore.watchValue(\"key\", function (newValue, action, oldValue) {\n\t\t\tspyNewValue = newValue;\n\t\t\tspyOldValue = oldValue;\n\t\t\tspyEvent = action;\n\t\t}, this);\n\n\t\tstore.set(\"key\", \"emily\");\n\n\t\texpect(spyNewValue).toBe(\"emily\");\n\t\texpect(spyEvent).toBe(\"added\");\n\n\t\tstore.set(\"key\", \"olives\");\n\n\t\texpect(spyNewValue).toBe(\"olives\");\n\t\texpect(spyEvent).toBe(\"updated\");\n\t\texpect(spyOldValue).toBe(\"emily\");\n\t});\n\n\tit(\"can update the property of an object nested in a store and publish an event\", function () {\n\t\tvar store = new Store({\n\t\t\t\tkey: {}\n\t\t\t}),\n\t\t\tupdatedValue = false;\n\n\t\tstore.watchValue(\"key\", function (value) {\n\t\t\tupdatedValue = value;\n\t\t}, this);\n\n\t\tstore.update(\"key\", \"a.b.c\", \"emily\");\n\n\t\texpect(updatedValue.a.b.c).toBe(\"emily\");\n\n\t});\n\n\tit(\"can delete multiple items in one function call\", function () {\n\t\tvar store = new Store([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]);\n\n\t\tstore.delAll([0,1,2]);\n\n\t\texpect(store.count()).toBe(3);\n\n\t\texpect(store.get(0)).toBe(\"d\");\n\t\texpect(store.get(1)).toBe(\"e\");\n\t\texpect(store.get(2)).toBe(\"f\");\n\t});\n\n\tit(\"can delete multiple properties in one function call\", function () {\n\t\tvar store = new Store({a: 10, b: 20, c: 30});\n\n\t\tstore.delAll([\"a\", \"b\"]);\n\n\t\texpect(store.count()).toBe(1);\n\n\t\texpect(store.has(\"a\")).toBe(false);\n\t\texpect(store.has(\"b\")).toBe(false);\n\t\texpect(store.has(\"c\")).toBe(true);\n\t});\n\n\tit(\"can proxy methods to the inner data structure's methods\", function () {\n\t\tvar store = new Store([0, 2, 3]),\n\t\t\tnewValue;\n\n\t\tstore.watchValue(1, function (value) {\n\t\t\tnewValue = value;\n\t\t});\n\t\t// Splice can alter the store\n\t\tstore.alter(\"splice\", 1, 0, 1); // [0,1,2,3]\n\n\t\texpect(store.get(1)).toBe(1);\n\t\texpect(newValue).toBe(1);\n\n\t\t// Map doesn't alter it, just like calling map on any array\n\t\tvar newArray = store.alter(\"map\", function (value) {\n\t\t\treturn value * 2;\n\t\t});\n\n\t\texpect(newArray[3]).toBe(6);\n\t});\n\n\tit(\"can also proxy to any method of an object\", function () {\n\t\tvar store = new Store({a: 10});\n\n\t\texpect(store.alter(\"hasOwnProperty\", \"a\")).toBe(true);\n\t});\n\n\tit(\"has a function for iterating over it the same way being based on an object or an array\", function () {\n\t\tvar store = new Store({a: 10, b: 20}),\n\t\t\tcalls = [];\n\n\t\tstore.loop(function () {\n\t\t\tcalls.push(arguments);\n\t\t});\n\n\t\t// Note that it's lucky that this test passes\n\t\t// as loop doesn't guarantee the order in case of an object!\n\t\texpect(calls[0][0]).toBe(10);\n\t\texpect(calls[0][1]).toBe(\"a\");\n\n\t\texpect(calls[1][0]).toBe(20);\n\t\texpect(calls[1][1]).toBe(\"b\");\n\n\t\tstore = new Store([\"a\", \"b\"]),\n\t\tcalls = [];\n\n\t\tstore.loop(function () {\n\t\t\tcalls.push(arguments);\n\t\t});\n\n\t\texpect(calls[0][0]).toBe(\"a\");\n\t\texpect(calls[0][1]).toBe(0);\n\n\t\texpect(calls[1][0]).toBe(\"b\");\n\t\texpect(calls[1][1]).toBe(1);\n\t});\n\n\tit(\"has a function for resetting the whole store\", function () {\n\t\tvar store = new Store({a: 10}),\n\t\t\titemAdded;\n\n\t\t// Calling reset fires the diff events\n\t\tstore.watch(\"added\", function (key) {\n\t\t\titemAdded = key;\n\t\t});\n\n\t\tstore.reset([\"a\"]);\n\n\t\texpect(store.get(0)).toBe(\"a\");\n\n\t\texpect(itemAdded).toBe(0);\n\t});\n\n\tit(\"can return the jsonified version of itself\", function () {\n\t\tvar store = new Store({a: undefined}),\n\t\t\tjsonified;\n\n\t\texpect(store.has(\"a\")).toBe(true);\n\n\t\tjsonified = store.toJSON();\n\t\texpect(Tools.count(jsonified)).toBe(0);\n\t});\n\n\tit(\"can return it's internal structure\", function () {\n\t\tvar store = new Store({a: 10}),\n\t\t\tinternal;\n\n\t\tinternal = store.dump();\n\n\t\texpect(internal.a).toBe(10);\n\n\t\t// The internal is not the object passed at init\n\t\texpect(store).not.toBe(internal);\n\n\t});\n\n});\n```\n\n## Promise\n\n```js\ndescribe(\"Promise is a fully Promise/A+ compliant implementation\", function () {\n\n\tit(\"calls the fulfillment callback within scope\", function () {\n\t\tvar promise = new Promise(),\n\t\t\tscope = {},\n\t\t\tthisObj,\n\t\t\tvalue;\n\n\t\tpromise.then(function (val) {\n\t\t\tthisObj = this;\n\t\t\tvalue = val;\n\t\t}, scope);\n\n\t\tpromise.fulfill(\"emily\");\n\n\t\texpect(value).toBe(\"emily\");\n\t\texpect(thisObj).toBe(scope);\n\t});\n\n\tit(\"calls the rejection callback within a scope\", function () {\n\t\tvar promise = new Promise(),\n\t\t\tscope = {},\n\t\t\tthisObj,\n\t\t\treason;\n\n\t\tpromise.then(null, function (res) {\n\t\t\tthisObj = this;\n\t\t\treason = res;\n\t\t}, scope);\n\n\t\tpromise.reject(false);\n\n\t\texpect(reason).toBe(false);\n\t\texpect(thisObj).toBe(scope);\n\t});\n\n\tit(\"can synchronise a promise with another one, or any thenable\", function () {\n\t\tvar promise1 = new Promise(),\n\t\t\tpromise2 = new Promise(),\n\t\t\tsynched;\n\n\t\tpromise2.sync(promise1);\n\n\t\tpromise2.then(function (value) {\n\t\t\tsynched = value;\n\t\t});\n\n\t\tpromise1.fulfill(true);\n\n\t\texpect(synched).toBe(true);\n\t});\n\n\tit(\"can return the reason of a rejected promise\", function () {\n\t\tvar promise = new Promise();\n\n\t\tpromise.reject(\"reason\");\n\n\t\texpect(promise.getReason()).toBe(\"reason\");\n\t});\n\n\tit(\"can return the value of a fulfilled promise\", function () {\n\t\tvar promise = new Promise();\n\n\t\tpromise.fulfill(\"emily\");\n\n\t\texpect(promise.getValue()).toBe(\"emily\");\n\t});\n\n\tit(\"passes all the promise-A+ tests specs\", function () {\n\t\texpect('225 tests complete (6 seconds)').toBeTruthy();\n\t});\n\n});\n```\n\n## StateMachine\n\n```js\ndescribe(\"StateMachine helps you with the control flow of your apps by removing branching if/else\", function () {\n\n\tit(\"will call specific actions depending on the current state and the triggered event\", function () {\n\t\tvar passCalled,\n\t\t\tcoinCalled,\n\n\t\t\tstateMachine = new StateMachine(\"opened\", {\n\t\t\t// It has an 'opened' state\n\t\t\t\"opened\": [\n\t\t\t\t// That accepts a 'pass' event that will execute the 'pass' action\n\t\t\t\t[\"pass\", function pass(event) {\n\t\t\t\t\tpassCalled = event;\n\t\t\t\t// And when done, it will transit to the 'closed' state\n\t\t\t\t}, \"closed\"]\n\t\t\t],\n\n\t\t\t// It also has a 'closed' state\n\t\t\t\"closed\": [\n\t\t\t\t// That accepts a 'coin' event that will execute the 'coin' action\n\t\t\t\t[\"coin\", function coin(event) {\n\t\t\t\t\tcoinCalled = event;\n\t\t\t\t// And when done, it will transit back to the 'opened' state\n\t\t\t\t}, \"opened\"]\n\t\t\t]\n\t\t});\n\n\t\texpect(stateMachine.getCurrent()).toBe(\"opened\");\n\n\t\texpect(stateMachine.event(\"nonExistingState\")).toBe(false);\n\t\texpect(stateMachine.event(\"pass\", \"hello\")).toBe(true);\n\t\texpect(passCalled).toBe(\"hello\");\n\n\t\texpect(stateMachine.getCurrent()).toBe(\"closed\");\n\t\texpect(stateMachine.event(\"coin\", \"2p\")).toBe(true);\n\t\texpect(coinCalled).toBe(\"2p\");\n\n\t\texpect(stateMachine.getCurrent()).toBe(\"opened\");\n\t});\n\n\tit(\"executes the action in the given scope\", function () {\n\t\tvar passThisObject,\n\t\t\tcoinThisObject,\n\t\t\tscope = {},\n\n\t\tstateMachine = new StateMachine(\"opened\", {\n\t\t\t\"opened\": [\n\t\t\t\t[\"pass\", function pass() {\n\t\t\t\t\tpassThisObject = this;\n\t\t\t\t}, scope, \"closed\"]\n\t\t\t],\n\t\t\t\"closed\": [\n\t\t\t\t[\"coin\", function coin() {\n\t\t\t\t\tcoinThisObject = this;\n\t\t\t\t}, scope, \"opened\"]\n\t\t\t]\n\t\t});\n\n\t\tstateMachine.event(\"pass\");\n\t\texpect(passThisObject).toBe(scope);\n\n\t\tstateMachine.event(\"coin\");\n\t\texpect(coinThisObject).toBe(scope);\n\t});\n\n\tit(\"can handle events that don't necessarily change the state\", function () {\n\t\tvar coinCalled,\n\t\t\tstateMachine = new StateMachine(\"opened\", {\n\t\t\t\"opened\": [\n\t\t\t\t[\"pass\", function pass() {\n\t\t\t\t\tpassThisObject = this;\n\t\t\t\t}, \"closed\"],\n\t\t\t\t[\"coin\", function coin() {\n\t\t\t\t\tcoinCalled = true;\n\t\t\t\t}]\n\t\t\t],\n\t\t\t\"closed\": [\n\t\t\t\t[\"coin\", function coin() {\n\t\t\t\t\tcoinThisbject = this;\n\t\t\t\t}, \"opened\"]\n\t\t\t]\n\t\t});\n\n\t\tstateMachine.event(\"coin\");\n\t\texpect(coinCalled).toBe(true);\n\t\texpect(stateMachine.getCurrent()).toBe(\"opened\");\n\n\t});\n\n\tit(\"can execute given actions upon entering or leaving a state\", function () {\n\t\tvar onEnter,\n\t\t\tonExit,\n\t\t\tstateMachine = new StateMachine(\"opened\", {\n\t\t\t\"opened\": [\n\t\t\t\t[\"pass\", function pass() {\n\t\t\t\t\t//\n\t\t\t\t}, \"closed\"],\n\n\t\t\t\t// Exit will be called upon leaving opened\n\t\t\t\t[\"exit\", function exit() {\n\t\t\t\t\tonExit = true;\n\t\t\t\t}]\n\t\t\t],\n\t\t\t\"closed\": [\n\n\t\t\t\t// Whereas entry will be called upon entering the state\n\t\t\t\t[\"entry\", function entry() {\n\t\t\t\t\tonEnter = true;\n\t\t\t\t}],\n\t\t\t\t[\"coin\", function coin() {\n\t\t\t\t\t//\n\t\t\t\t}, \"opened\"]\n\t\t\t]\n\t\t});\n\n\t\tstateMachine.event(\"pass\");\n\n\t\texpect(onExit).toBe(true);\n\t\texpect(onExit).toBe(true);\n\n\t\texpect(stateMachine.getCurrent()).toBe(\"closed\");\n\t});\n\n\tit(\"can be advanced to a given state\", function () {\n\t\tvar stateMachine = new StateMachine(\"opened\", {\n\t\t\t\"opened\": [\n\t\t\t\t[\"pass\", function pass() {\n\t\t\t\t\tpassThisObject = this;\n\t\t\t\t}, \"closed\"]\n\t\t\t],\n\t\t\t\"closed\": [\n\t\t\t\t[\"coin\", function coin() {\n\t\t\t\t\tcoinThisObject = this;\n\t\t\t\t}, \"opened\"]\n\t\t\t]\n\t\t});\n\n\t\texpect(stateMachine.advance(\"\")).toBe(false);\n\t\texpect(stateMachine.advance(\"closed\")).toBe(true);\n\t\texpect(stateMachine.getCurrent()).toBe(\"closed\");\n\n\t\texpect(stateMachine.advance(\"opened\")).toBe(true);\n\t\texpect(stateMachine.getCurrent()).toBe(\"opened\");\n\t});\n\n});\n\n});\n```\n\n## Transport\n\n```js\ndescribe(\"Transport hides and centralizes the logic behind requests\", function () {\n\n\tit(\"issues requests to request handlers\", function () {\n\n\t\tvar onEndCalled = false;\n\n\t\tvar requestsHandlers = new Store({\n\t\t\t// This function will handle the request specified by payload.\n\t\t\t// It will call the onEnd request when it has received all the data\n\t\t\t// It will call onData for each chunk of data that needs to be sent\n\t\t\tmyRequestHandler: function (payload, onEnd) {\n\t\t\t\tif (payload == \"whoami\") {\n\t\t\t\t\tonEnd(\"emily\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar transport = new Transport(requestsHandlers);\n\n\t\t// Issue a request on myRequestHandler with \"whoami\" in the payload\n\t\ttransport.request(\"myRequestHandler\", \"whoami\", function onEnd() {\n\t\t\tonEndCalled = true;\n\t\t})\n\n\t\texpect(onEndCalled).toBe(true);\n\t});\n\n\tit(\"accepts objects as payloads\", function () {\n\n\t\tvar requestsHandlers = new Store({\n\t\t\tmyRequestHandler: function (payload, onEnd) {\n\t\t\t\tonEnd(\"Hi \" + payload.firstname + \" \" + payload.lastname);\n\t\t\t}\n\t\t}),\n\t\ttransport,\n\t\tresponse;\n\n\t\ttransport = new Transport(requestsHandlers);\n\n\t\ttransport.request(\"myRequestHandler\", {\n\t\t\tfirstname: \"olivier\",\n\t\t\tlastname: \"scherrer\"\n\t\t}, function onEnd(data) {\n\t\t\tresponse = data;\n\t\t});\n\n\t\texpect(response).toBe(\"Hi olivier scherrer\");\n\n\t});\n\n\tit(\"can also listen to channels and receive data in several chunks\", function () {\n\n\t\tvar requestsHandlers = new Store({\n\t\t\t// When onEnd is called, no further data can be sent.\n\t\t\t// But when the channel must no be closed, onData can be called instead\n\t\t\tmyRequestHandler: function (payload, onEnd, onData) {\n\t\t\t\tonData(\"chunk1\");\n\t\t\t\tonData(\"chunk2\");\n\t\t\t\tonData(\"chunk3\");\n\t\t\t\tonEnd(\"chunk4\");\n\t\t\t}\n\t\t}),\n\t\tresponse = [];\n\n\t\tvar transport = new Transport(requestsHandlers);\n\n\t\ttransport.listen(\"myRequestHandler\", {}, function onData(data) {\n\t\t\tresponse.push(data);\n\t\t});\n\n\t\texpect(response.length).toBe(4);\n\t\texpect(response[0]).toBe(\"chunk1\");\n\t\texpect(response[3]).toBe(\"chunk4\");\n\n\t});\n\n\tit(\"can close a listening channel on the client end point\", function () {\n\t\tvar aborted = false;\n\n\t\tvar requestsHandlers = new Store({\n\t\t\tmyRequestHandler: function () {\n\t\t\t\treturn function abort() {\n\t\t\t\t\taborted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t\ttransport = new Transport(requestsHandlers),\n\t\tabort;\n\n\t\tabort = transport.listen(\"myRequestHandler\", \"\", function () {});\n\n\t\tabort();\n\n\t\texpect(aborted).toBe(true);\n\t});\n\n});\n```\n\n### Going further\n\nCheck out Olives for scalable MV* applications in the browser. https://github.com/flams/olives\n\n1.3.4 - 03 MAR 2013\n-------------------\n\n* Added advance to the state machine\n\n1.3.3 - 28 JAN 2013\n-------------------\n\n* Added Store.dump\n* When store publishes a change event, it publishes both the new and the previous value\n\n1.3.2 - 22 JAN 2013\n-------------------\n\n* Fixed emily-server breaking olives\n* Updated requirejs\n\n1.3.1 - 1 JAN 2013\n-------------------\n\n* Promise has been updated to pass the promise/A+ specs according to\nhttps://github.com/promises-aplus/promises-tests\n* Updated StateMachine so new transitions can be added on the fly\n* Moved the CouchDB handler to CouchDB Emily Tools\n\n1.3.0 - 16 DEC 2012\n-------------------\n\n * Promise has been updated to pass the promise/A specs according to https://github.com/domenic/promise-tests\n * The build now includes the source files as you should be able to drop them into your application\n   to decide how you want to load and optimize them\n\n1.2.0 - 07 OCT 2012\n-------------------\n\nRemoval of CouchDBStore - now part of CouchDB-Emily-Tools\n\n\n",
  "readmeFilename": "README.md",
  "_id": "emily@1.3.5",
  "_from": "emily@1.3.5"
}
